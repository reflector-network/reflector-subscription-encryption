{"version":3,"file":"encryption.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAoB,WAAID,IAExBD,EAAiB,WAAIC,GACtB,CATD,CASGK,MAAM,I,mBCRT,IAAIC,EAAsB,CCA1BA,EAAwB,CAACL,EAASM,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDF,EAAwB,CAACQ,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,I,4BCAlF,MAAM,OAACI,GAAUC,OACXC,EAAiB,IAAIC,WAAW,CAAC,EAAG,EAAG,IACvCC,EAAc,IAAIC,YAejB,SAASC,EAAajB,GAEzB,IAAIkB,EAAS,QACTC,EAAQ,UAKZ,OAPAnB,EAAMoB,EAAcpB,IAGZqB,OAAS,MACbH,EAAS,OACTC,EAAQ,WAELR,EAAOW,UACVJ,EACAlB,EACA,CAACuB,KAAM,WAAYC,KAAM,YACzB,EACA,CAACL,GAET,CAOA,SAASM,EAAazB,GAClB,OAAOW,EAAOW,UACV,MACAF,EAAcpB,GACd,CAACuB,KAAM,YACP,EACA,CAAC,UAAW,WAEpB,CA6FA,SAASH,EAAcM,GACnB,MAAoB,iBAATA,EACAX,EAAYY,OAAOD,GAC1BA,aAAgBE,YACT,IAAId,WAAWY,GACnBA,CACX,CACA,MAEA,EAFmB,CAACG,QA3DbC,eAAuBC,EAAcL,GAExC,MAAMM,EAjFCpB,OAAOqB,gBAAgB,IAAInB,WAAW,KAmFvCoB,EAAKtB,OAAOqB,gBAAgB,IAAInB,WAAW,KAC3CqB,QAAsBxB,EAAOkB,QAAQ,CAACN,KAAM,UAAWW,YAAWT,EAAaO,GAASZ,EAAcM,IAEtGU,EAAW,IAAItB,WAAW,IAChCsB,EAASC,IAAIL,EAAQ,GACrBI,EAASC,IAAIH,EAAI,IACjB,MAAMI,QAA0B3B,EAAOkB,QAAQ,CAACN,KAAM,YAAaQ,EAAcK,GAE3EG,EAAM,IAAIzB,WAAW,IAAMqB,EAAcK,YAG/C,OAFAD,EAAIF,IAAI,IAAIvB,WAAWwB,GAAoB,GAC3CC,EAAIF,IAAI,IAAIvB,WAAWqB,GAAgB,KAChCI,CACX,EA2C6BE,QAnCtBX,eAAuBY,EAAeP,GACzC,IAGI,KADAA,EAAgBf,EAAce,KACRA,EAAcd,OAAS,IACzC,OAAO,KACLqB,aAAyBC,YAC3BD,QAAsBzB,EAAayB,IAGvC,MAAMN,EAAW,IAAItB,iBAAiBH,EAAO8B,QAAQ,CAAClB,KAAM,YAAamB,EAAeP,EAAcS,SAAS,EAAG,OAElHT,EAAgBA,EAAcS,SAAS,KACvC,MAAMZ,QAAeP,EAAaW,EAASQ,SAAS,EAAG,KACjDL,QAAY5B,EAAO8B,QAAQ,CAAClB,KAAM,UAAWW,GAAIE,EAASQ,SAAS,KAAMZ,EAAQG,GACvF,OAAO,IAAIrB,WAAWyB,EAC1B,CAAE,MAAOM,GAEL,OADAC,QAAQC,MAAMF,GACP,IACX,CACJ,EAesCG,OArE/B,SAAgBtB,GACnB,OAAOd,OAAOD,OAAOsC,OAAO,UAAW7B,EAAcM,GACzD,EAmE8CwB,mBA9FvCpB,iBACH,MAAMqB,QAAgBvC,OAAOD,OAAOyC,YAChC,CACI7B,KAAM,WACN8B,cAAe,KACfxC,iBACAW,KAAM,YAEV,EACA,CAAC,UAAW,aAGT8B,EAAYC,SAAmBC,QAAQC,IAAI,CAC9C7C,OAAOD,OAAO+C,UAAU,QAASP,EAAQG,YACzC1C,OAAOD,OAAO+C,UAAU,OAAQP,EAAQI,aAG5C,MAAO,CAACD,aAAYC,YACxB,EA4EkEtC,gB","sources":["webpack://encryption/webpack/universalModuleDefinition","webpack://encryption/webpack/bootstrap","webpack://encryption/webpack/runtime/define property getters","webpack://encryption/webpack/runtime/hasOwnProperty shorthand","webpack://encryption/./src/encryption.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"encryption\"] = factory();\n\telse\n\t\troot[\"encryption\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const {subtle} = crypto\r\nconst publicExponent = new Uint8Array([1, 0, 1])\r\nconst textEncoder = new TextEncoder()\r\n\r\n/**\r\n * Generate random 32-byte encryption key\r\n * @return {Uint8Array}\r\n */\r\nfunction generateRandomEncryptionKey() {\r\n    return crypto.getRandomValues(new Uint8Array(32))\r\n}\r\n\r\n/**\r\n * Import binary RSA key as CryptoKey for encryption/decryption\r\n * @param {ArrayBuffer|Uint8Array|string} key - Raw RSA key in binary format\r\n * @return {Promise<CryptoKey>}\r\n */\r\nexport function importRSAKey(key) {\r\n    key = normalizeData(key)\r\n    let format = 'pkcs8'\r\n    let usage = 'decrypt'\r\n    if (key.length < 500) {//private keys are longer than public\r\n        format = 'spki'\r\n        usage = 'encrypt'\r\n    }\r\n    return subtle.importKey(\r\n        format,\r\n        key,\r\n        {name: 'RSA-OAEP', hash: 'SHA-256'},\r\n        true,\r\n        [usage]\r\n    )\r\n}\r\n\r\n/**\r\n * Import binary AES key as CryptoKey for encryption/decryption\r\n * @param {ArrayBuffer|Uint8Array|string} key - Raw AES key in binary format\r\n * @return {Promise<CryptoKey>}\r\n */\r\nfunction importAESKey(key) {\r\n    return subtle.importKey(\r\n        'raw',\r\n        normalizeData(key),\r\n        {name: 'AES-GCM'},\r\n        true,\r\n        ['encrypt', 'decrypt']\r\n    )\r\n}\r\n\r\n/**\r\n * Generate pair of keys for RSA-OAEP encryption\r\n * @return {Promise<{privateKey: ArrayBuffer, publicKey: ArrayBuffer}>}\r\n */\r\nexport async function generateRSAKeyPair() {\r\n    const keyPair = await crypto.subtle.generateKey(\r\n        {\r\n            name: 'RSA-OAEP',\r\n            modulusLength: 2048,\r\n            publicExponent,\r\n            hash: 'SHA-256'\r\n        },\r\n        true,\r\n        ['encrypt', 'decrypt']\r\n    )\r\n\r\n    const [privateKey, publicKey] = await Promise.all([\r\n        crypto.subtle.exportKey('pkcs8', keyPair.privateKey),\r\n        crypto.subtle.exportKey('spki', keyPair.publicKey)\r\n    ])\r\n\r\n    return {privateKey, publicKey}\r\n}\r\n\r\n/**\r\n * Get SHA256 hash of the data\r\n * @param {ArrayBuffer|Uint8Array|string} data - Data to hash\r\n * @returns {Promise<ArrayBuffer>}\r\n */\r\nexport function sha256(data) {\r\n    return crypto.subtle.digest('SHA-256', normalizeData(data))\r\n}\r\n\r\n/**\r\n * Encrypt the data with a public RSA key\r\n * @param {CryptoKey} rsaPublicKey - Public key for RSA encryption\r\n * @param {ArrayBuffer|Uint8Array|string} data - Data to encrypt\r\n * @return {Uint8Array}\r\n */\r\nexport async function encrypt(rsaPublicKey, data) {\r\n    //every time a new encryption key is generated\r\n    const aesKey = generateRandomEncryptionKey()\r\n    //encrypt data with AES\r\n    const iv = crypto.getRandomValues(new Uint8Array(12))\r\n    const encryptedData = await subtle.encrypt({name: 'AES-GCM', iv}, await importAESKey(aesKey), normalizeData(data))\r\n    //encrypt the key itself + IV with RSA\r\n    const aesKeyIV = new Uint8Array(44)\r\n    aesKeyIV.set(aesKey, 0)\r\n    aesKeyIV.set(iv, 32)\r\n    const encryptedAesKeyIv = await subtle.encrypt({name: 'RSA-OAEP'}, rsaPublicKey, aesKeyIV)\r\n    //concatenate both key and data\r\n    const res = new Uint8Array(256 + encryptedData.byteLength)\r\n    res.set(new Uint8Array(encryptedAesKeyIv), 0)\r\n    res.set(new Uint8Array(encryptedData), 256)\r\n    return res\r\n}\r\n\r\n/**\r\n * Decrypt the data with a private RSA key\r\n * @param {CryptoKey} rsaPrivateKey - Private key for RSA encryption\r\n * @param {ArrayBuffer|Uint8Array|string} encryptedData - Data to decrypt\r\n * @return {Promise<Uint8Array|null>}\r\n */\r\nexport async function decrypt(rsaPrivateKey, encryptedData) {\r\n    try {\r\n        //parse and validate input\r\n        encryptedData = normalizeData(encryptedData)\r\n        if (!encryptedData || encryptedData.length < 256)\r\n            return null\r\n        if (!(rsaPrivateKey instanceof CryptoKey)) { //try to import\r\n            rsaPrivateKey = await importRSAKey(rsaPrivateKey)\r\n        }\r\n        //decode AES KEY\r\n        const aesKeyIV = new Uint8Array(await subtle.decrypt({name: 'RSA-OAEP'}, rsaPrivateKey, encryptedData.subarray(0, 256)))\r\n        //the rest of the input is the encrypted data itself\r\n        encryptedData = encryptedData.subarray(256)\r\n        const aesKey = await importAESKey(aesKeyIV.subarray(0, 32))\r\n        const res = await subtle.decrypt({name: 'AES-GCM', iv: aesKeyIV.subarray(32)}, aesKey, encryptedData)\r\n        return new Uint8Array(res)\r\n    } catch (e) {\r\n        console.error(e)\r\n        return null\r\n    }\r\n}\r\n\r\n/**\r\n * Normalize binary input data\r\n * @param {ArrayBuffer|Uint8Array|string} data - Binary data\r\n * @return {Uint8Array}\r\n * @internal\r\n */\r\nfunction normalizeData(data) {\r\n    if (typeof data === 'string')\r\n        return textEncoder.encode(data)\r\n    if (data instanceof ArrayBuffer)\r\n        return new Uint8Array(data)\r\n    return data\r\n}\r\nconst encryption = {encrypt, decrypt, sha256, generateRSAKeyPair, importRSAKey}\r\n\r\nexport default encryption"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","subtle","crypto","publicExponent","Uint8Array","textEncoder","TextEncoder","importRSAKey","format","usage","normalizeData","length","importKey","name","hash","importAESKey","data","encode","ArrayBuffer","encrypt","async","rsaPublicKey","aesKey","getRandomValues","iv","encryptedData","aesKeyIV","set","encryptedAesKeyIv","res","byteLength","decrypt","rsaPrivateKey","CryptoKey","subarray","e","console","error","sha256","digest","generateRSAKeyPair","keyPair","generateKey","modulusLength","privateKey","publicKey","Promise","all","exportKey"],"sourceRoot":""}