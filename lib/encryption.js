!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.encryption=t():e.encryption=t()}(this,(()=>(()=>{"use strict";var e={d:(t,r)=>{for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},t={};e.d(t,{default:()=>i});const{subtle:r}=crypto,n=new Uint8Array([1,0,1]),a=new TextEncoder;function o(e){let t="pkcs8",n="decrypt";return(e=c(e)).length<500&&(t="spki",n="encrypt"),r.importKey(t,e,{name:"RSA-OAEP",hash:"SHA-256"},!0,[n])}function y(e){return r.importKey("raw",c(e),{name:"AES-GCM"},!0,["encrypt","decrypt"])}function c(e){return"string"==typeof e?a.encode(e):e instanceof ArrayBuffer?new Uint8Array(e):e}const i={encrypt:async function(e,t){const n=crypto.getRandomValues(new Uint8Array(32)),a=crypto.getRandomValues(new Uint8Array(12)),o=await r.encrypt({name:"AES-GCM",iv:a},await y(n),c(t)),i=new Uint8Array(44);i.set(n,0),i.set(a,32);const p=await r.encrypt({name:"RSA-OAEP"},e,i),s=new Uint8Array(256+o.byteLength);return s.set(new Uint8Array(p),0),s.set(new Uint8Array(o),256),s},decrypt:async function(e,t){try{if(!(t=c(t))||t.length<256)return null;e instanceof CryptoKey||(e=await o(e));const n=new Uint8Array(await r.decrypt({name:"RSA-OAEP"},e,t.subarray(0,256)));t=t.subarray(256);const a=await y(n.subarray(0,32)),i=await r.decrypt({name:"AES-GCM",iv:n.subarray(32)},a,t);return new Uint8Array(i)}catch(e){return console.error(e),null}},sha256:function(e){return crypto.subtle.digest("SHA-256",c(e))},generateRSAKeyPair:async function(){const e=await crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:2048,publicExponent:n,hash:"SHA-256"},!0,["encrypt","decrypt"]),[t,r]=await Promise.all([crypto.subtle.exportKey("pkcs8",e.privateKey),crypto.subtle.exportKey("spki",e.publicKey)]);return{privateKey:t,publicKey:r}},importRSAKey:o};return t.default})()));
//# sourceMappingURL=encryption.js.map